import { io, Scalar, serialization, Tensor } from '@tensorflow/tfjs-core';
import { TensorContainer } from '@tensorflow/tfjs-core/dist/tensor_types';
import { History } from './base_callbacks';
import { Dataset } from './engine/dataset_stub';
import { Layer } from './engine/topology';
import { Model, ModelCompileArgs, ModelEvaluateArgs } from './engine/training';
import { ModelEvaluateDatasetArgs, ModelFitDatasetArgs } from './engine/training_dataset';
import { ModelFitArgs } from './engine/training_tensors';
import { Kwargs, Shape } from './types';
import { PyJsonDict } from './types';
export declare function modelFromJSON(modelAndWeightsConfig: ModelAndWeightsConfig | PyJsonDict, customObjects?: serialization.ConfigDict): Promise<Model>;
export interface ModelAndWeightsConfig {
    modelTopology: PyJsonDict;
    weightsManifest?: io.WeightsManifestConfig;
    pathPrefix?: string;
}
export interface ModelPredictArgs {
    batchSize?: number;
    verbose?: boolean;
}
export declare function loadModelInternal(pathOrIOHandler: string | io.IOHandler, strict?: boolean): Promise<Model>;
export declare function loadModelFromIOHandler(handler: io.IOHandler, customObjects?: serialization.ConfigDict, strict?: boolean): Promise<Model>;
export interface SequentialArgs {
    layers?: Layer[];
    name?: string;
}
export declare class Sequential extends Model {
    static className: string;
    private model;
    private _updatable;
    constructor(args?: SequentialArgs);
    private checkShape(layer);
    add(layer: Layer): void;
    pop(): void;
    call(inputs: Tensor | Tensor[], kwargs: Kwargs): Tensor | Tensor[];
    build(inputShape?: Shape | Shape[]): void;
    countParams(): number;
    summary(lineLength?: number, positions?: number[], printFn?: (message?: any, ...optionalParams: any[]) => void): void;
    setWeights(weights: Tensor[]): void;
    updatable: boolean;
    evaluate(x: Tensor | Tensor[], y: Tensor | Tensor[], args?: ModelEvaluateArgs): Scalar | Scalar[];
    evaluateDataset<T extends TensorContainer>(dataset: Dataset<T>, args: ModelEvaluateDatasetArgs): Promise<Scalar | Scalar[]>;
    predict(x: Tensor | Tensor[], args?: ModelPredictArgs): Tensor | Tensor[];
    predictOnBatch(x: Tensor): Tensor | Tensor[];
    compile(args: ModelCompileArgs): void;
    fit(x: Tensor | Tensor[] | {
        [inputName: string]: Tensor;
    }, y: Tensor | Tensor[] | {
        [inputName: string]: Tensor;
    }, args?: ModelFitArgs): Promise<History>;
    fitDataset<T extends TensorContainer>(dataset: Dataset<T>, args: ModelFitDatasetArgs<T>): Promise<History>;
    trainOnBatch(x: Tensor | Tensor[] | {
        [inputName: string]: Tensor;
    }, y: Tensor | Tensor[] | {
        [inputName: string]: Tensor;
    }): Promise<number | number[]>;
    static fromConfig<T extends serialization.Serializable>(cls: serialization.SerializableConstructor<T>, config: serialization.ConfigDict, customObjects?: serialization.ConfigDict, fastWeightInit?: boolean): T;
    stopTraining: boolean;
    getConfig(): any;
}
