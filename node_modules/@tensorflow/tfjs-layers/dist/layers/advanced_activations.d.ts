import { serialization, Tensor } from '@tensorflow/tfjs-core';
import { Constraint } from '../constraints';
import { Layer, LayerArgs } from '../engine/topology';
import { Initializer, InitializerIdentifier } from '../initializers';
import { Regularizer } from '../regularizers';
import { Kwargs, Shape } from '../types';
export interface ReLULayerArgs extends LayerArgs {
    maxValue?: number;
}
export declare class ReLU extends Layer {
    static className: string;
    maxValue: number;
    constructor(args?: ReLULayerArgs);
    call(inputs: Tensor | Tensor[], kwargs: Kwargs): Tensor | Tensor[];
    computeOutputShape(inputShape: Shape | Shape[]): Shape | Shape[];
    getConfig(): serialization.ConfigDict;
}
export interface LeakyReLULayerArgs extends LayerArgs {
    alpha?: number;
}
export declare class LeakyReLU extends Layer {
    static className: string;
    readonly alpha: number;
    readonly DEFAULT_ALPHA: number;
    constructor(args?: LeakyReLULayerArgs);
    call(inputs: Tensor | Tensor[], kwargs: Kwargs): Tensor | Tensor[];
    computeOutputShape(inputShape: Shape | Shape[]): Shape | Shape[];
    getConfig(): serialization.ConfigDict;
}
export interface PReLULayerArgs extends LayerArgs {
    alphaInitializer?: Initializer | InitializerIdentifier;
    alphaRegularizer?: Regularizer;
    alphaConstraint?: Constraint;
    sharedAxes?: number | number[];
}
export declare class PReLU extends Layer {
    static className: string;
    private readonly alphaInitializer;
    private readonly alphaRegularizer;
    private readonly alphaConstraint;
    private readonly sharedAxes;
    private alpha;
    readonly DEFAULT_ALPHA_INITIALIZER: InitializerIdentifier;
    constructor(args?: PReLULayerArgs);
    build(inputShape: Shape | Shape[]): void;
    call(inputs: Tensor | Tensor[], kwargs: Kwargs): Tensor | Tensor[];
    getConfig(): serialization.ConfigDict;
}
export interface ELULayerArgs extends LayerArgs {
    alpha?: number;
}
export declare class ELU extends Layer {
    static className: string;
    readonly alpha: number;
    readonly DEFAULT_ALPHA: number;
    constructor(args?: ELULayerArgs);
    call(inputs: Tensor | Tensor[], kwargs: Kwargs): Tensor | Tensor[];
    computeOutputShape(inputShape: Shape | Shape[]): Shape | Shape[];
    getConfig(): serialization.ConfigDict;
}
export interface ThresholdedReLULayerArgs extends LayerArgs {
    theta?: number;
}
export declare class ThresholdedReLU extends Layer {
    static className: string;
    readonly theta: number;
    private readonly thetaTensor;
    readonly DEFAULT_THETA: number;
    constructor(args?: ThresholdedReLULayerArgs);
    call(inputs: Tensor | Tensor[], kwargs: Kwargs): Tensor | Tensor[];
    computeOutputShape(inputShape: Shape | Shape[]): Shape | Shape[];
    getConfig(): serialization.ConfigDict;
}
export interface SoftmaxLayerArgs extends LayerArgs {
    axis?: number;
}
export declare class Softmax extends Layer {
    static className: string;
    readonly axis: number;
    readonly softmax: (t: Tensor, a?: number) => Tensor;
    readonly DEFAULT_AXIS: number;
    constructor(args?: SoftmaxLayerArgs);
    call(inputs: Tensor | Tensor[], kwargs: Kwargs): Tensor | Tensor[];
    computeOutputShape(inputShape: Shape | Shape[]): Shape | Shape[];
    getConfig(): serialization.ConfigDict;
}
